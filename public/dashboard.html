// Replace the entire script section at the end of dashboard.html with this fixed version
// This goes after line 1245 (after the closing </style> tag and before </body>)

<script>
    // API Configuration
    const API_URL = '/api';
    let currentFilter = 'all';
    let currentWarehouse = 'all';
    let activityData = [];
    let filteredData = [];
    let statsCache = {};
    let refreshInterval;
    let connectionCheckInterval;
    let simulationInterval;
    let map;
    let markers = {};
    let warehouseMarkers = {};
    let geofences = {};
    let geofencesVisible = false;
    let driverPaths = {};
    
    // Miami area coordinates
    const MIAMI_CENTER = [25.7617, -80.1918];
    const WAREHOUSES = {
        'Miami Distribution Center': [25.7617, -80.1918],
        'Orlando Warehouse': [28.5383, -81.3792],
        'Fort Lauderdale Hub': [26.1224, -80.1373],
        'Tampa Depot': [27.9506, -82.4572]
    };
    
    // Geofence zones (5km radius around warehouses)
    const GEOFENCE_RADIUS = 5000; // meters
    const SPEED_LIMIT_ZONE = 3000; // 3km radius for speed limit
    
    // Demo driver names
    const DEMO_DRIVERS = [
        'John Smith', 'Sarah Johnson', 'Mike Davis', 'Lisa Wilson',
        'Robert Taylor', 'Maria Garcia', 'James Brown', 'Jennifer Lee',
        'David Martinez', 'Emily Anderson', 'Chris Thompson', 'Amanda White'
    ];
    
    // Initialize Map
    function initializeMap() {
        // Create map centered on Miami
        map = L.map('map').setView(MIAMI_CENTER, 10);
        
        // Add tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // Add warehouse markers and geofences
        Object.entries(WAREHOUSES).forEach(([name, coords]) => {
            // Warehouse marker
            const marker = L.marker(coords, {
                icon: L.divIcon({
                    className: 'custom-div-icon',
                    html: `<div style="background: #3B82F6; color: white; padding: 8px; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">üè¢</div>`,
                    iconSize: [40, 40],
                    iconAnchor: [20, 40]
                })
            }).addTo(map);
            
            marker.bindPopup(`<strong>${name}</strong><br>Warehouse Location`);
            warehouseMarkers[name] = marker;
            
            // Create geofence circles
            const geofence = L.circle(coords, {
                color: '#EF4444',
                fillColor: '#EF4444',
                fillOpacity: 0.1,
                weight: 2,
                dashArray: '5, 10',
                radius: GEOFENCE_RADIUS
            });
            
            geofence.bindPopup(`<strong>${name} Geofence</strong><br>5km radius zone`);
            geofences[name] = geofence;
        });
    }
    
    // Toggle geofence visibility
    function toggleGeofences() {
        geofencesVisible = !geofencesVisible;
        
        Object.values(geofences).forEach(geofence => {
            if (geofencesVisible) {
                geofence.addTo(map);
            } else {
                map.removeLayer(geofence);
            }
        });
        
        showToast(geofencesVisible ? 'Geofences visible' : 'Geofences hidden', 'info');
    }
    
    // Center map view
    function centerMap() {
        if (currentWarehouse !== 'all' && WAREHOUSES[currentWarehouse]) {
            map.setView(WAREHOUSES[currentWarehouse], 11);
        } else {
            // Center on Miami or fit all markers
            if (Object.keys(markers).length > 0) {
                const group = new L.featureGroup(Object.values(markers));
                map.fitBounds(group.getBounds().pad(0.1));
            } else {
                map.setView(MIAMI_CENTER, 10);
            }
        }
        showToast('Map view centered', 'info');
    }
    
    // Load demo data
    async function loadDemoData() {
        showToast('Generating demo drivers...', 'info');
        
        // Clear existing data
        activityData = [];
        Object.values(markers).forEach(marker => map.removeLayer(marker));
        markers = {};
        
        // Generate demo notifications
        const demoNotifications = [];
        const statuses = ['en-route', 'arrived', 'delayed', 'en-route', 'en-route'];
        const locations = [
            'I-95 North, Mile Marker 45',
            'Highway 1, Key Largo',
            'I-75 South, Exit 260',
            'US-441, Davie',
            'Turnpike, Exit 71',
            'A1A, Fort Lauderdale',
            'I-595 West',
            'SR-836, Miami'
        ];
        
        for (let i = 0; i < 8; i++) {
            const warehouse = Object.keys(WAREHOUSES)[Math.floor(Math.random() * 4)];
            const status = statuses[Math.floor(Math.random() * statuses.length)];
            
            demoNotifications.push({
                _id: 'demo-' + Date.now() + '-' + i,
                driver: DEMO_DRIVERS[i],
                status: status,
                location: locations[i],
                warehouse: warehouse,
                timestamp: new Date(Date.now() - Math.random() * 3600000), // Within last hour
                estimatedArrival: status === 'en-route' ? `${Math.floor(Math.random() * 60) + 10} minutes` : null,
                isRead: status === 'arrived' ? false : true,
                priority: status === 'delayed' ? 'high' : 'normal',
                notes: status === 'delayed' ? 'Traffic congestion reported' : null
            });
        }
        
        activityData = demoNotifications;
        applyFilters();
        
        // Add markers for each driver
        demoNotifications.forEach(notification => {
            if (notification.status !== 'completed') {
                addDriverMarker(notification, true);
            }
        });
        
        // Start simulation
        startSimulation();
        
        showToast('Demo data loaded! Watch drivers move in real-time', 'success');
    }
    
    // Add driver marker to map with real-time tracking
    function addDriverMarker(driver, isDemo = false) {
        const driverId = driver._id;
        
        // Generate coordinates
        let lat, lng;
        
        if (isDemo || !driver.coordinates) {
            // Generate random coordinates near warehouse
            const warehouse = WAREHOUSES[driver.warehouse] || MIAMI_CENTER;
            const distance = driver.status === 'arrived' ? 0.01 : 0.1 + Math.random() * 0.2;
            const angle = Math.random() * 2 * Math.PI;
            lat = warehouse[0] + distance * Math.cos(angle);
            lng = warehouse[1] + distance * Math.sin(angle);
        } else {
            lat = driver.coordinates.latitude;
            lng = driver.coordinates.longitude;
        }
        
        // Remove existing marker if any
        if (markers[driverId]) {
            map.removeLayer(markers[driverId]);
        }
        
        // Get marker color based on status
        const colors = {
            'en-route': '#F59E0B',
            'arrived': '#10B981',
            'delayed': '#EF4444',
            'completed': '#3B82F6'
        };
        const color = colors[driver.status] || '#6B7280';
        
        // Create custom marker with driver initials
        const initials = driver.driver.split(' ').map(n => n[0]).join('');
        const marker = L.marker([lat, lng], {
            icon: L.divIcon({
                className: 'custom-div-icon',
                html: `<div style="background: ${color}; color: white; padding: 8px; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.3); font-size: 12px;">${initials}</div>`,
                iconSize: [36, 36],
                iconAnchor: [18, 36]
            })
        }).addTo(map);
        
        // Add popup with real-time info
        const updatePopup = () => {
            const distance = calculateDistanceToWarehouse(marker.getLatLng(), driver.warehouse);
            const speed = driver.status === 'en-route' ? Math.floor(Math.random() * 20) + 50 : 0;
            
            marker.bindPopup(`
                <strong>${driver.driver}</strong><br>
                Status: <span style="color: ${color}; font-weight: bold;">${driver.status}</span><br>
                Location: ${driver.location}<br>
                Warehouse: ${driver.warehouse}<br>
                Distance: ${distance.toFixed(1)} km<br>
                Speed: ${speed} mph<br>
                ${driver.estimatedArrival ? `ETA: ${driver.estimatedArrival}` : ''}
                ${driver.notes ? `<br><em>${driver.notes}</em>` : ''}
            `);
        };
        
        updatePopup();
        markers[driverId] = marker;
        
        // Store driver data for tracking
        marker.driverData = driver;
        
        // Check geofence
        checkGeofence(driverId, marker.getLatLng(), driver.warehouse);
    }
    
    // Calculate distance to warehouse
    function calculateDistanceToWarehouse(latlng, warehouseName) {
        const warehouse = WAREHOUSES[warehouseName];
        if (!warehouse) return 0;
        
        const R = 6371; // Earth radius in km
        const dLat = (warehouse[0] - latlng.lat) * Math.PI / 180;
        const dLon = (warehouse[1] - latlng.lng) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(latlng.lat * Math.PI / 180) * Math.cos(warehouse[0] * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }
    
    // Check geofence violations
    function checkGeofence(driverId, latlng, warehouseName) {
        const warehouse = WAREHOUSES[warehouseName];
        if (!warehouse) return;
        
        const distance = calculateDistanceToWarehouse(latlng, warehouseName) * 1000; // Convert to meters
        const driver = activityData.find(d => d._id === driverId);
        
        if (driver && driver.status === 'en-route') {
            // Check if entering geofence
            if (distance < GEOFENCE_RADIUS && !driver.inGeofence) {
                driver.inGeofence = true;
                showGeofenceAlert(driver.driver, warehouseName, 'entered');
                
                // Update status to arriving soon
                if (distance < 1000) {
                    driver.estimatedArrival = 'Less than 5 minutes';
                }
            }
            // Check if exiting geofence
            else if (distance > GEOFENCE_RADIUS && driver.inGeofence) {
                driver.inGeofence = false;
                showGeofenceAlert(driver.driver, warehouseName, 'exited');
            }
        }
    }
    
    // Show geofence alert
    function showGeofenceAlert(driverName, warehouseName, action) {
        const alert = document.createElement('div');
        alert.className = 'geofence-alert';
        alert.innerHTML = `
            <span class="geofence-alert-icon">‚ö†Ô∏è</span>
            <div>
                <strong>Geofence Alert!</strong><br>
                ${driverName} has ${action} ${warehouseName} zone
            </div>
        `;
        
        document.body.appendChild(alert);
        
        // Remove after 5 seconds
        setTimeout(() => {
            alert.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => alert.remove(), 300);
        }, 5000);
        
        // Update recent alerts panel
        updateRecentAlerts(`${driverName} ${action} ${warehouseName} zone`);
    }
    
    // Update recent alerts panel
    function updateRecentAlerts(message) {
        const alertsPanel = document.getElementById('recentAlerts');
        const time = new Date().toLocaleTimeString();
        
        const alertHtml = `
            <div class="summary-item">
                <span class="summary-label">${time}</span>
                <span class="summary-value" style="font-size: 14px; color: var(--danger-color);">${message}</span>
            </div>
        `;
        
        if (alertsPanel.children[0]?.textContent.includes('No recent alerts')) {
            alertsPanel.innerHTML = alertHtml;
        } else {
            alertsPanel.innerHTML = alertHtml + alertsPanel.innerHTML;
            // Keep only last 5 alerts
            if (alertsPanel.children.length > 5) {
                alertsPanel.removeChild(alertsPanel.lastChild);
            }
        }
    }
    
    // Start simulation for demo data
    function startSimulation() {
        if (simulationInterval) clearInterval(simulationInterval);
        
        simulationInterval = setInterval(() => {
            // Move en-route drivers
            Object.entries(markers).forEach(([id, marker]) => {
                const driver = activityData.find(d => d._id === id);
                if (driver && driver.status === 'en-route') {
                    const warehouse = WAREHOUSES[driver.warehouse] || MIAMI_CENTER;
                    const currentPos = marker.getLatLng();
                    const warehouseLatlng = L.latLng(warehouse[0], warehouse[1]);
                    
                    // Calculate movement
                    const distance = calculateDistanceToWarehouse(currentPos, driver.warehouse);
                    const speed = 0.001 + Math.random() * 0.002; // Simulation speed
                    
                    // Move towards warehouse
                    const lat = currentPos.lat + (warehouseLatlng.lat - currentPos.lat) * speed;
                    const lng = currentPos.lng + (warehouseLatlng.lng - currentPos.lng) * speed;
                    
                    marker.setLatLng([lat, lng]);
                    
                    // Check geofence
                    checkGeofence(id, marker.getLatLng(), driver.warehouse);
                    
                    // Update ETA
                    if (distance < 10) {
                        driver.estimatedArrival = `${Math.floor(distance * 3)} minutes`;
                    }
                    
                    // Check if arrived
                    if (distance < 0.5) {
                        driver.status = 'arrived';
                        driver.estimatedArrival = null;
                        driver.isRead = false;
                        showToast(`${driver.driver} has arrived at ${driver.warehouse}!`, 'success');
                        applyFilters();
                    }
                }
            });
        }, 2000); // Update every 2 seconds for smooth movement
    }
    
    // Initialize all dashboard components
    async function initializeDashboard() {
        try {
            await Promise.all([
                loadStats(),
                loadRecentActivity(),
                checkConnection()
            ]);
            
            // Check if we have data from API
            if (activityData.length === 0) {
                setTimeout(() => {
                    showToast('No live data found. Click "Demo Data" to see the system in action!', 'info');
                }, 1000);
            }
        } catch (error) {
            console.error('Initialization error:', error);
            showToast('Using offline mode. Click "Demo Data" for simulation.', 'info');
        }
    }
    
    // Load dashboard statistics
    async function loadStats() {
        try {
            const response = await fetch(`${API_URL}/stats`);
            const result = await response.json();
            
            if (result.success) {
                updateStatsDisplay(result.data);
                statsCache = result.data;
            }
        } catch (error) {
            console.error('Error loading stats:', error);
            updateConnectionStatus(false);
        }
    }
    
    // Update stats display
    function updateStatsDisplay(stats) {
        // Update main stats
        const overview = stats.overview || {};
        
        // Count by status from actual data
        const enRoute = countByStatus('en-route');
        const arrived = countByStatus('arrived');
        const delayed = countByStatus('delayed');
        const completed = countByStatus('completed');
        
        document.getElementById('totalDrivers').textContent = activityData.length || '0';
        document.getElementById('enRouteCount').textContent = enRoute;
        document.getElementById('arrivedCount').textContent = arrived;
        document.getElementById('issuesCount').textContent = delayed;
        
        // Update summary panel
        document.getElementById('totalTrips').textContent = activityData.length;
        document.getElementById('completedTrips').textContent = completed;
        document.getElementById('inProgressTrips').textContent = enRoute;
        document.getElementById('issuesReported').textContent = delayed;
        
        // Calculate average trip time (mock calculation)
        const avgMinutes = activityData.length > 0 ? Math.floor(Math.random() * 120) + 60 : 0;
        document.getElementById('avgTripTime').textContent = avgMinutes > 0 ? `${Math.floor(avgMinutes/60)}h ${avgMinutes%60}m` : '0h 0m';
        
        // Update other stats
        document.getElementById('busiestTime').textContent = activityData.length > 0 ? '2-4 PM' : '-';
        document.getElementById('topDriver').textContent = getTopDriver();
        document.getElementById('fleetUtilization').textContent = activityData.length > 0 ? Math.floor((enRoute + arrived) / activityData.length * 100) + '%' : '0%';
    }
    
    // Count activities by status
    function countByStatus(status) {
        return filteredData.filter(item => item.status === status).length;
    }
    
    // Get top driver
    function getTopDriver() {
        if (activityData.length === 0) return '-';
        
        const driverCounts = {};
        activityData.forEach(item => {
            driverCounts[item.driver] = (driverCounts[item.driver] || 0) + 1;
        });
        
        const topDriver = Object.entries(driverCounts).sort((a, b) => b[1] - a[1])[0];
        return topDriver ? topDriver[0] : '-';
    }
    
    // Load recent activity
    async function loadRecentActivity() {
        try {
            const response = await fetch(`${API_URL}/notifications?limit=50`);
            const result = await response.json();
            
            if (result.success && result.data && result.data.length > 0) {
                activityData = result.data;
                applyFilters();
                
                // Update map markers
                activityData.forEach(driver => {
                    if (driver.status !== 'completed') {
                        addDriverMarker(driver);
                    }
                });
            }
        } catch (error) {
            console.error('Error loading activity:', error);
            // Don't show error toast here, handled in initialization
        }
    }
    
    // Apply filters to activity data
    function applyFilters() {
        filteredData = activityData;
        
        // Apply status filter
        if (currentFilter !== 'all') {
            filteredData = filteredData.filter(item => item.status === currentFilter);
        }
        
        // Apply warehouse filter
        if (currentWarehouse !== 'all') {
            filteredData = filteredData.filter(item => item.warehouse === currentWarehouse);
        }
        
        displayActivity(filteredData);
        updateStatsDisplay(statsCache);
    }
    
    // Display activity items
    function displayActivity(data) {
        const activityList = document.getElementById('activityList');
        
        if (data.length === 0) {
            activityList.innerHTML = `
                <div class="no-data">
                    <div class="no-data-icon">üì≠</div>
                    <p>No activities found for selected filters.</p>
                </div>
            `;
            return;
        }
        
        activityList.innerHTML = data.map(item => {
            const timeAgo = getTimeAgo(new Date(item.timestamp));
            const iconClass = getStatusIconClass(item.status);
            const icon = getStatusIcon(item.status);
            const actionButton = getActionButton(item);
            
            return `
                <div class="activity-item" data-id="${item._id}" onclick="window.focusOnDriver('${item._id}')">
                    <div class="activity-icon ${iconClass}">${icon}</div>
                    <div class="activity-content">
                        <div class="activity-title">${item.driver} - ${getStatusText(item.status)}</div>
                        <div class="activity-details">
                            <span class="activity-time">üïê ${timeAgo}</span>
                            <span class="activity-location">üìç ${item.location}</span>
                            <span>üè¢ ${item.warehouse}</span>
                        </div>
                        ${item.notes ? `<div style="margin-top: 4px; font-size: 13px; color: var(--gray-color);">${item.notes}</div>` : ''}
                    </div>
                    <div class="activity-status">
                        ${actionButton}
                    </div>
                </div>
            `;
        }).join('');
    }
    
    // Focus map on specific driver
    function focusOnDriver(driverId) {
        if (markers[driverId]) {
            const marker = markers[driverId];
            map.setView(marker.getLatLng(), 13);
            marker.openPopup();
        }
    }
    
    // Get status icon class
    function getStatusIconClass(status) {
        const classes = {
            'en-route': 'en-route',
            'arrived': 'arrived',
            'completed': 'completed',
            'delayed': 'delayed'
        };
        return classes[status] || 'en-route';
    }
    
    // Get status icon
    function getStatusIcon(status) {
        const icons = {
            'en-route': 'üöö',
            'arrived': '‚úÖ',
            'completed': 'üìã',
            'delayed': '‚ö†Ô∏è'
        };
        return icons[status] || 'üöö';
    }
    
    // Get status text
    function getStatusText(status) {
        const texts = {
            'en-route': 'is en route',
            'arrived': 'has arrived',
            'completed': 'completed delivery',
            'delayed': 'is delayed'
        };
        return texts[status] || status;
    }
    
    // Get action button for activity item
    function getActionButton(item) {
        if (item.status === 'arrived' && !item.isRead) {
            return `<button class="btn check-in-btn" onclick="event.stopPropagation(); window.checkInDriver(event, '${item._id}', '${item.driver.replace(/'/g, "\\'")}')">Check In</button>`;
        } else if (item.estimatedArrival && item.status === 'en-route') {
            return `<span class="badge badge-warning">ETA: ${item.estimatedArrival}</span>`;
        } else if (item.status === 'completed') {
            return `<span class="badge badge-success">Completed</span>`;
        } else if (item.status === 'delayed') {
            return `<span class="badge badge-danger">Delayed</span>`;
        }
        return '';
    }
    
    // Check in driver
    async function checkInDriver(event, notificationId, driverName) {
        if (event) {
            event.stopPropagation(); // Prevent triggering the parent onclick
        }
        
        if (confirm(`Check in ${driverName}?`)) {
            try {
                // For demo data, just update locally
                if (notificationId.startsWith('demo-')) {
                    const driver = activityData.find(d => d._id === notificationId);
                    if (driver) {
                        driver.status = 'completed';
                        driver.isRead = true;
                        
                        // Remove marker from map
                        if (markers[notificationId]) {
                            map.removeLayer(markers[notificationId]);
                            delete markers[notificationId];
                        }
                        
                        applyFilters();
                        showToast(`${driverName} has been checked in`, 'success');
                    }
                    return;
                }
                
                // For real data, call API
                const response = await fetch(`${API_URL}/notifications/${notificationId}/read`, {
                    method: 'PATCH'
                });
                
                if (response.ok) {
                    showToast(`${driverName} has been checked in`, 'success');
                    
                    // Remove marker from map
                    if (markers[notificationId]) {
                        map.removeLayer(markers[notificationId]);
                        delete markers[notificationId];
                    }
                    
                    await loadRecentActivity();
                    await loadStats();
                }
            } catch (error) {
                showToast('Failed to check in driver', 'error');
            }
        }
    }
    
    // Make functions globally accessible
    window.checkInDriver = checkInDriver;
    
    // Filter activity
    function filterActivity(filter, button) {
        currentFilter = filter;
        
        // Update active button
        document.querySelectorAll('.filter-pill').forEach(pill => {
            pill.classList.remove('active');
        });
        button.classList.add('active');
        
        // Apply filters
        applyFilters();
        
        showToast(`Showing ${filter === 'all' ? 'all' : filter} activities`, 'info');
    }
    
    // Filter by warehouse
    function filterByWarehouse() {
        const warehouse = document.getElementById('warehouseFilter').value;
        currentWarehouse = warehouse;
        
        applyFilters();
        
        // Center map on warehouse if specific one selected
        if (warehouse !== 'all' && WAREHOUSES[warehouse]) {
            map.setView(WAREHOUSES[warehouse], 11);
        }
        
        showToast(`Filtering by ${warehouse === 'all' ? 'all warehouses' : warehouse}`, 'info');
    }
    
    // Start live updates
    function startLiveUpdates() {
        // Update every 30 seconds
        refreshInterval = setInterval(() => {
            if (activityData.length > 0 && !activityData[0]._id.startsWith('demo-')) {
                // Only refresh if using real data
                loadRecentActivity();
                loadStats();
            }
        }, 30000);
        
        // Check connection every 10 seconds
        connectionCheckInterval = setInterval(checkConnection, 10000);
    }
    
    // Check connection status
    async function checkConnection() {
        try {
            const response = await fetch(`${API_URL}/health`);
            const result = await response.json();
            updateConnectionStatus(result.status === 'OK');
        } catch (error) {
            updateConnectionStatus(false);
        }
    }
    
    // Update connection status display
    function updateConnectionStatus(connected) {
        const badge = document.getElementById('connectionStatus');
        if (connected) {
            badge.className = 'connection-badge connected';
            badge.innerHTML = '<span class="status-dot"></span><span>Connected</span>';
        } else {
            badge.className = 'connection-badge disconnected';
            badge.innerHTML = '<span class="status-dot"></span><span>Disconnected</span>';
        }
    }
    
    // Update clock
    function updateClock() {
        const updateTime = () => {
            const now = new Date();
            const timeString = now.toLocaleTimeString('en-US', { 
                hour: 'numeric', 
                minute: '2-digit',
                hour12: true 
            });
            document.getElementById('currentTime').textContent = timeString;
        };
        
        updateTime();
        setInterval(updateTime, 1000);
    }
    
    // Get time ago string
    function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        
        if (seconds < 60) return 'just now';
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
        const days = Math.floor(hours / 24);
        return `${days} day${days > 1 ? 's' : ''} ago`;
    }
    
    // Quick Actions - Fixed navigation
    function showNewNotification() {
        // Navigate to index.html
        window.location.href = 'index.html';
        
        // Store the desired tab in sessionStorage
        sessionStorage.setItem('activeTab', 'new-notification');
    }
    
    function showInspectionForm() {
        // Navigate to index.html
        window.location.href = 'index.html';
        
        // Store the desired tab in sessionStorage
        sessionStorage.setItem('activeTab', 'new-inspection');
    }
    
    function viewReports() {
        // Navigate to index.html and show inspections tab
        window.location.href = 'index.html';
        
        // Store the desired tab in sessionStorage
        sessionStorage.setItem('activeTab', 'inspections');
    }
    
    function manageDrivers() {
        // Navigate to admin panel
        window.location.href = 'admin.html';
    }
    
    // Refresh Dashboard
    function refreshDashboard() {
        showToast('Refreshing dashboard...', 'info');
        
        // Clear and reload everything
        Object.values(markers).forEach(marker => map.removeLayer(marker));
        markers = {};
        
        loadRecentActivity();
        loadStats();
    }
    
    // Export Activity
    function exportActivity() {
        showToast('Preparing export...', 'info');
        
        // Create CSV content
        const csv = [
            ['Driver', 'Status', 'Location', 'Warehouse', 'Time', 'Notes'],
            ...filteredData.map(item => [
                item.driver,
                item.status,
                item.location,
                item.warehouse,
                new Date(item.timestamp).toLocaleString(),
                item.notes || ''
            ])
        ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
        
        // Download file
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dispatch-activity-${new Date().toISOString().split('T')[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        showToast('Activity exported successfully', 'success');
    }
    
    // Show Toast Message
    function showToast(message, type = 'info') {
        // Remove any existing toasts
        document.querySelectorAll('.toast').forEach(toast => toast.remove());
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: '‚úÖ',
            error: '‚ùå',
            info: '‚ÑπÔ∏è'
        };
        
        toast.innerHTML = `
            <span style="font-size: 20px;">${icons[type]}</span>
            <span>${message}</span>
        `;
        
        document.body.appendChild(toast);
        
        // Remove after 3 seconds
        setTimeout(() => {
            toast.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
        if (refreshInterval) clearInterval(refreshInterval);
        if (connectionCheckInterval) clearInterval(connectionCheckInterval);
        if (simulationInterval) clearInterval(simulationInterval);
    });
    
    // Make all functions globally accessible for onclick handlers
    window.filterActivity = filterActivity;
    window.filterByWarehouse = filterByWarehouse;
    window.refreshDashboard = refreshDashboard;
    window.centerMap = centerMap;
    window.toggleGeofences = toggleGeofences;
    window.loadDemoData = loadDemoData;
    window.showNewNotification = showNewNotification;
    window.showInspectionForm = showInspectionForm;
    window.viewReports = viewReports;
    window.manageDrivers = manageDrivers;
    window.exportActivity = exportActivity;
    window.focusOnDriver = focusOnDriver;
    
    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initializeMap();
        initializeDashboard();
        startLiveUpdates();
        updateClock();
    });
</script>
